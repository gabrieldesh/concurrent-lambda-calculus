typedefs
  Bool     = 1 + 1 ;
  Nat      = rec x : *ns. @(1 + x) ;
  
  Servidor = &{ ?Nat.!Bool.End, ?Nat.?Nat.!Nat.End } ;
  Cliente  = +{ !Nat.?Bool.End, !Nat.!Nat.?Nat.End }
end

let un false : Bool = inl [1] {} in
let un true  : Bool = inr [1] {} in

let un zero : Nat = fold [Nat] @(inl [Nat] {}) in

let un succ : Nat -o Nat =
  \lin n : Nat.
    let @unfoldN = unfold n in
    fold [Nat] @(inr [1] (fold [Nat] @unfoldN))
in

let un discard : Nat -o 1 =
  \lin n : Nat.
    let @x = unfold n in {}
in

let un isZero : Nat -o Bool =
  \lin n : Nat.
    let @unfoldN = unfold n in
    case unfoldN of
      inl unit  -> let {} = unit in true ;
      inr predN -> let {} = discard predN in false
in

let rec add : Nat -o Nat -o Nat =
  \lin n : Nat.
  \lin m : Nat.
    let @unfoldN = unfold n in
    case unfoldN of
      inl unit  -> let {} = unit in m ;
      inr predN -> succ (add predN m)
in

-------------------------------------------------------

let un servidor : Servidor -o 1 =
  \lin s0 : Servidor.
    branch s0 of
      left s1 ->
        let {n, s2} = receive s1         in
        let lin s3  = send (isZero n) s2 in
        close s3 ;
      
      right s1 ->
        let {n1, s2} = receive s1          in
        let {n2, s3} = receive s2          in
        let lin s4   = send (add n1 n2) s3 in
        close s4
in

let un cliente : Cliente -o Nat =
  \lin c0 : Cliente.
    let lin c1  = select right c0 in
    let lin c2  = send (succ zero) c1 in
    let lin c3  = send (succ zero) c2 in
    let {n, c4} = receive c3          in
    let {}      = close c4            in
    n
in

let lin c = fork servidor in
cliente c